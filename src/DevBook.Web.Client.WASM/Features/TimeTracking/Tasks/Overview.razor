@page "/tasks"

<PageTitle>Tasks</PageTitle>
<div class="flex m-4 space-x-4 overflow-y-auto">
    <MudCard Class="grow">
        <MudCardHeader>
            <CardHeaderContent>
                <MudText Typo="Typo.h5">Work Tasks</MudText>
            </CardHeaderContent>
        </MudCardHeader>
        <MudCardContent>
            <div class="flex flex-col items-start">
                <MudButton Class="flex-none" StartIcon="@Icons.Material.Filled.Add" Color="Color.Primary" OnClick="() => ShowCreateTaskCard()">Add New Task</MudButton>
                <MudButton Class="flex-none" StartIcon="@Icons.Material.Outlined.PlayArrow" Color="Color.Primary">Start Work</MudButton>
            </div>
            <MudExpansionPanels Dense="true" MultiExpansion="true">
                @foreach (var item in _pageModel.TasksInDays)
                {
                    <MudExpansionPanel Text="@(item.Day.DayOfWeek.ToString() + $", {item.Day.ToString("dd.MM.yyyy")}")" IsExpanded="IsFirstDay(item.Day)">
                        <MudList Clickable="true" @bind-SelectedItem="_selectedItem" @bind-SelectedValue="_selectedTask" Color="Color.Primary">
                            <div>
                                @if (_pageModel.RunningTask is not null && IsFirstDay(DateOnly.FromDateTime(_pageModel.RunningTask.Date.DateTime)))
                                {
                                    <MudListItem OnClick="() => ShowUpdateRunningTaskCard(_pageModel.RunningTask.Id)" Value="_pageModel.RunningTask">
                                        <div class="flex justify-between items-center">
                                            <MudText>@_pageModel.RunningTask.Description</MudText>
                                            <MudText>
                                                @_runningTaskElapsedTime
                                                <MudIcon Class="animate-spin" Icon="@Icons.Material.Filled.Refresh" Size="Size.Large" />
                                            </MudText>
                                        </div>
                                    </MudListItem>
                                }
                                
                            </div>
                            @foreach(var task in item.Tasks)
                            {
                                <MudListItem OnClick="() => ShowUpdateTaskCard(task.Id)" Value="task">
                                    <div class="flex justify-between items-center">
                                        <MudText>@task.Description</MudText>
                                        <MudText>@GetTaskElapsedTime(task.Start, task.End)</MudText>
                                    </div>

                                </MudListItem>
                            }
                        </MudList>
                    </MudExpansionPanel>
                }
            </MudExpansionPanels>
        </MudCardContent>
    </MudCard>

    <CreateOrUpdateTaskCard @ref="_updateTaskCard" Class="grow" Visible="_showEditTaskCard" OnCancel="() => HideEditTaskCard()" OnCreateOrUpdate="() => RefreshItems()" />
    <UpdateRunningTaskCard @ref="_updateRuningTaskCard" Class="grow" Visible="_showRunningTaskCard" OnCancel="() => HideEditTaskCard()" OnUpdate="() => RefreshItems()" />
</div>

@code {
    [Inject] private IExecutor Executor { get; set; } = null!;
    [Inject] private NavigationManager NavigationManager { get; init; } = null!;


    private CreateOrUpdateTaskCard _updateTaskCard = null!;
    private UpdateRunningTaskCard _updateRuningTaskCard = null!;
    MudListItem? _selectedItem;
    object? _selectedTask;
    private PageModel _pageModel = new();
    private bool _showEditTaskCard = false;
    private bool _showRunningTaskCard = false;
    private string _runningTaskElapsedTime = string.Empty;
    private bool _runningTaskRendered = false;
    private bool _loading = false;

    protected override async Task OnInitializedAsync()
    {
        _runningTaskRendered = false;
        await RefreshItems();

        // Timer should not be awaited, othewise will block execution because it is potentially infinity
        StarRunningTaskElapsedTimeTimer();
    }

    private bool IsFirstDay(DateOnly taskDate)
    {
        return _pageModel.TasksInDays.FirstOrDefault()?.Day == taskDate;
    }

    private async Task StarRunningTaskElapsedTimeTimer()
    {
        var timer = new PeriodicTimer(TimeSpan.FromSeconds(1));
        while (await timer.WaitForNextTickAsync())
        {
            if (_pageModel.RunningTask is not null)
            {
                _runningTaskElapsedTime = GetTaskElapsedTime(DateTime.Now.TimeOfDay, _pageModel.RunningTask.Start);
                StateHasChanged();
            }
        }
    }

    private string GetTaskElapsedTime(TimeSpan? end, TimeSpan? start)
    {
        return (end - start)?.Humanize(2, minUnit: TimeUnit.Second) ?? string.Empty;
    }

    private IEnumerable<PageModel.TasksInDay> GroupTasksByDay(IEnumerable<PageModel.WorkTask> tasks)
    {
        List<PageModel.TasksInDay> tasksInDays = new();
        var dayGroups = tasks.OrderByDescending(x => x.Date).GroupBy(x => DateOnly.FromDateTime(x.Date.DateTime));
        foreach(var group in dayGroups)
        {
            tasksInDays.Add(new PageModel.TasksInDay(group.Key, group.Select(x => x).ToArray()));
        }

        return tasksInDays;
    }

    private bool FilterFunc(PageModel.TasksInDay tasksInDay, string searchString)
    {
        if (string.IsNullOrWhiteSpace(searchString))
            return true;

        if (tasksInDay.Tasks.Any(x => x.Description?.Contains(searchString, StringComparison.OrdinalIgnoreCase) == true))
            return true;

        return false;
    }

    private async Task ShowUpdateTaskCard(Guid id)
    {
        await _updateTaskCard.PopulateCreateOrUpdateTaskCard(id);
        _showRunningTaskCard = false;
        _showEditTaskCard = true;
    }

    private async Task ShowCreateTaskCard(Guid? id = null)
    {
        await _updateTaskCard.PopulateCreateOrUpdateTaskCard(id: null);
        _showRunningTaskCard = false;
        _showEditTaskCard = true;
    }

    private async Task ShowUpdateRunningTaskCard(Guid id)
    {
        await _updateRuningTaskCard.PopulateUpdateRunningTaskCard(id: id);
        _showEditTaskCard = false;
        _showRunningTaskCard = true;
    }

    private void HideEditTaskCard(Guid? id = null)
    {
        _showEditTaskCard = false;
        _showRunningTaskCard = false;
    }

    private async Task RefreshItems()
    {
        _loading = true;
        _pageModel = await Executor.ExecuteQuery(new GetPageModelQuery());
        _runningTaskElapsedTime = GetTaskElapsedTime(_pageModel.RunningTask?.End, _pageModel.RunningTask?.Start);
        _loading = false;
    }

    private sealed record GetPageModelQuery : IQuery<PageModel>;

    private sealed record PageModel
    {
        public WorkTask? RunningTask { get; set; } = null;
        public IEnumerable<TasksInDay> TasksInDays { get; set; } = [];

        public sealed record WorkTask(Guid Id, string? Description, DateTimeOffset Date, TimeSpan Start, TimeSpan? End);
        public sealed record TasksInDay
        {
            public DateOnly Day { get; init; }
            public WorkTask[] Tasks { get; init; }

            public TasksInDay(DateOnly day, WorkTask[] tasks)
            {
                Day = day;
                Tasks = tasks;
            }
        }
    }

    private sealed class GetPageModelQueryHandler(IDevBookWebApiActionExecutor devBookWebApiActionExecutor)
        : IQueryHandler<GetPageModelQuery, PageModel>
    {
        public async Task<PageModel> Handle(GetPageModelQuery request, CancellationToken cancellationToken)
        {
            var result = await devBookWebApiActionExecutor.Execute(x => x.WorkTasks_ListAsync(cancellationToken));
            return result.Match(
                workTasksList => new PageModel
                {
                    RunningTask = workTasksList.ActiveWorkTask is null
                        ? null
                        : new PageModel.WorkTask(
                            workTasksList.ActiveWorkTask.Id,
                            workTasksList.ActiveWorkTask.Description,
                            workTasksList.ActiveWorkTask.Date,
                            workTasksList.ActiveWorkTask.Start,
                            workTasksList.ActiveWorkTask.End),
                    TasksInDays = workTasksList?.WorkTasksInDay?.Select(
                        x => new PageModel.TasksInDay(DateOnly.Parse(x.Key), x.Value.Select(x => new PageModel.WorkTask(x.Id, x.Description, x.Date, x.Start, x.End)).ToArray())) ?? []
                },
                apiError => throw new DevBookException(apiError.Errors));
        }
    }
}